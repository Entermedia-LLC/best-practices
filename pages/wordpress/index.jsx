// React.js imports
import { useEffect } from "react";

// Next.js imports
import Head from "next/head";

// Component imports
import Template from "../../components/templates/Default/Default";
import Heading from "../../components/atoms/Headline/Headline";

// Library imports
import prismjs from "prismjs";
import "prismjs/themes/prism-coy.css";
import "prismjs/components/prism-markup";

export default function WordPress() {
  useEffect(() => {
    prismjs.highlightAll();
  }, []);

  return (
    <>
      <Head>
        <title>QA Best Practices</title>
        <meta name="description" content="Generated by create next app" />
        <link rel="icon" href="/favicon.ico" />
      </Head>

      <Template>
        <section>
          <Heading section="1" id="wordpress">
            WordPress
          </Heading>
          <Heading section="2" id="performance" showLink>
            Performance
          </Heading>
          <p>
            Writing performant code is absolutely critical, especially at the
            enterprise level. There are a number of strategies and best
            practices we must employ to ensure our code is optimized for
            high-traffic situations.
          </p>
          <Heading section="3" showLink>
            Efficient Database Queries
          </Heading>
          <p>
            When querying the database in WordPress, you should generally use a{" "}
            <a
              href="https://developer.wordpress.org/reference/classes/wp_query/"
              target="_blank"
              rel="noreferrer"
            >
              <code>WP_Query</code>
            </a>{" "}
            object. <code>WP_Query</code> objects take a number of useful
            arguments and do things behind-the-scenes that other database access
            methods such as{" "}
            <a
              href="https://developer.wordpress.org/reference/functions/get_posts/"
              target="_blank"
              rel="noreferrer"
            >
              <code>get_posts()</code>
            </a>{" "}
            do not.
          </p>
          <p>Here are a few key points:</p>
          <ul>
            <li>
              <p>Only run the queries that you need.</p>

              <p>
                A new <code>WP_Query</code> object runs five queries by default,
                including calculating pagination and priming the term and meta
                caches. Each of the following arguments will remove a query:
              </p>

              <ul>
                <li>
                  <code>&apos;no_found_rows&apos; =&gt; true</code>: useful when
                  pagination is not needed.
                </li>
                <li>
                  <code>&apos;update_post_meta_cache&apos; =&gt; false</code>:
                  useful when post meta will not be utilized.
                </li>
                <li>
                  <code>&apos;update_post_term_cache&apos; =&gt; false</code>:
                  useful when taxonomy terms will not be utilized.
                </li>
                <li>
                  <code>&apos;fields&apos; =&gt; &apos;ids&apos;</code>: useful
                  when only the post IDs are needed (less typical).
                </li>
              </ul>
            </li>
            <li>
              <p>
                Do not use <code>posts_per_page =&gt; -1</code>.
              </p>

              <p>
                This is a performance hazard. What if we have 100,000 posts?
                This could crash the site. If you are writing a widget, for
                example, and just want to grab all of a custom post type,
                determine a reasonable upper limit for your situation.
              </p>

              <pre>
                <code className="language-php">{`<?php
// Query for 500 posts.
new WP_Query( array(
  'posts_per_page' => 500,
));
?>`}</code>
              </pre>
            </li>
            <li>
              <p>
                Do not use <code>$wpdb</code> or <code>get_posts()</code> unless
                you have good reason.
              </p>

              <p>
                <code>get_posts()</code> actually calls <code>WP_Query</code>,
                but calling <code>get_posts()</code> directly bypasses a number
                of filters by default. Not sure whether you need these things or
                not? You probably don’t.
              </p>
            </li>
            <li>
              <p>
                If you don’t plan to paginate query results, always pass{" "}
                <code>no_found_rows =&gt; true</code> to <code>WP_Query</code>.
              </p>

              <p>
                This will tell WordPress not to run{" "}
                <code>SQL_CALC_FOUND_ROWS</code> on the SQL query, drastically
                speeding up your query. <code>SQL_CALC_FOUND_ROWS</code>{" "}
                calculates the total number of rows in your query which is
                required to know the total amount of “pages” for pagination.
              </p>

              <pre>
                <code className="language-php">{`<?php
// Skip SQL_CALC_FOUND_ROWS for performance (no pagination).
new WP_Query( array(
  'no_found_rows' => true,
));
?>`}</code>
              </pre>
            </li>
            <li>
              <p>
                Avoid using <code>post__not_in</code>.
              </p>

              <p>
                In most cases it’s quicker to filter out the posts you don’t
                need in PHP instead of within the query. This also means it can
                take advantage of better caching. This won’t work correctly
                (without additional tweaks) for pagination.
              </p>

              <p>Use:</p>

              <pre>
                <code className="language-php">{`<?php
$foo_query = new WP_Query( array(
    'post_type' => 'post',
    'posts_per_page' => 30 + count( $posts_to_exclude )
) );

if ( $foo_query->have_posts() ) :
    while ( $foo_query->have_posts() ) :
        $foo_query->the_post();
        if ( in_array( get_the_ID(), $posts_to_exclude ) ) {
            continue;
        }
        the_title();
    endwhile;
endif;
?>`}</code>
              </pre>

              <p>Instead of:</p>

              <pre>
                <code className="language-php">{`<?php
$foo_query = new WP_Query( array(
    'post_type' => 'post',
    'posts_per_page' => 30,
    'post__not_in' => $posts_to_exclude
) );
?>`}</code>
              </pre>

              <p>
                See{" "}
                <a
                  href="https://vip.wordpress.com/documentation/performance-improvements-by-removing-usage-of-post__not_in/"
                  target="_blank"
                  rel="noreferrer"
                >
                  WordPress VIP
                </a>
                .
              </p>
            </li>
            <li>
              <p>
                A{" "}
                <a
                  href="https://wordpress.org/support/article/taxonomies/"
                  target="_blank"
                  rel="noreferrer"
                >
                  taxonomy
                </a>{" "}
                is a tool that lets us group or classify posts.
              </p>

              <p>
                <a
                  href="https://wordpress.org/support/article/custom-fields/"
                  target="_blank"
                  rel="noreferrer"
                >
                  Post meta
                </a>{" "}
                lets us store unique information about specific posts. As such
                the way post meta is stored does not facilitate efficient post
                lookups. Generally, looking up posts by post meta should be
                avoided (sometimes it can’t). If you have to use one, make sure
                that it’s not the main query and that it’s cached.
              </p>
            </li>
            <li>
              <p>
                Passing <code>cache_results =&gt; false</code> to{" "}
                <code>WP_Query</code> is usually not a good idea.
              </p>

              <p>
                If <code>cache_results =&gt; true</code> (which is true by
                default if you have caching enabled and an object cache setup),{" "}
                <code>WP_Query</code> will cache the posts found among other
                things. It makes sense to use{" "}
                <code>cache_results =&gt; false</code> in rare situations
                (possibly WP-CLI commands).
              </p>
            </li>
            <li>
              <p>Multi-dimensional queries should be avoided.</p>

              <p>Examples of multi-dimensional queries include:</p>

              <pre>
                <code className="language-markup">{`* Querying for posts based on terms across multiple taxonomies
* Querying multiple post meta keys`}</code>
              </pre>

              <p>
                Each extra dimension of a query joins an extra database table.
                Instead, query by the minimum number of dimensions possible and
                use PHP to filter out results you don’t need.
              </p>

              <p>Here is an example of a 2-dimensional query:</p>

              <pre>
                <code className="language-php">{`<?php
// Query for posts with both a particular category and tag.
new WP_Query( array(
  'category_name' => 'cat-slug',
  'tag' => 'tag-slug',
));
?>`}</code>
              </pre>
            </li>
          </ul>
          <Heading section="2" id="wpgraphql" showLink>
            WPGraphQL
          </Heading>
          <p>
            If you are choosing to use GraphQL on a WordPress project, it is
            recommended to use the WPGraphQL plugin. This plugin will return
            WordPress data in JSON format through a GraphQL endpoint - in many
            cases you won’t need to write the schema yourself. This will give
            you all the benefits of concatenating your data requests as well as
            easy access to your data as it is output by WordPress. You can
            retrieve your data by passing a query directly into a simple fetch
            request:
          </p>
          <pre>
            <code className="language-javascript">{`fetch('/graphql', {
    method: 'POST',
    headers: { 'Content-Type': 'application/json' },
    body: JSON.stringify({ query: '[your query string goes here]' }),
  }).then((res) => res.json());`}</code>
          </pre>
          <p>
            The above code snippet will help you get started in making requests
            to the GraphQL service.
          </p>
        </section>
      </Template>
    </>
  );
}
